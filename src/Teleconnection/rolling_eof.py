import numpy as np
import pandas as pd
import xarray as xr
from tqdm.notebook import tqdm, trange

import src.Teleconnection.spatial_pattern as ssp
import src.Teleconnection.tools as tools


def rolling_eof(xarr, nmode=2, win_size=10, fixed_pattern="all", standard=True):
    """do eof analysis with in a rolling window.

    rolling EOF is like rolling mean, here the default window is 10 years. The EOFs, PCs and
    exp_var of one specifice year is decomposed from a combined dataset,which is generated by
    combing the data 5 years before and 4 years later (totaly 10 years of data), and by concating
    the ensemble dim together, we have a series of 1000 length.

    **Arguments**:

        *xarr*: the DataArray that is going to be decomposed by rolling_eof. [time,lat,lon,ens,height,decade]
        *nmode*: the number of modes reserved.
        *window*: the rolling window.
        *fixed_pattern*: string, determine how the pcs generated.
                       - if fixed_pattern = 'all', then 'pc' is calculated by projecting the original
                       fields onto a temporally-fixed pattern. i.e, the 'pc' is the second output
                       (pcx) of 'doeof' on a combined dataset, which concates all the  ensembles
                       and years togerther. In which case the spatial pattern is assumed to be
                       fixed.
                       - if fixed_pattern = 'first'. then 'pc' is calculted by projecting the original
                       fields onto the spatial pattern of the first 10 years.
                       - if fixed_pattern = 'last', the 'pc' is calculated by projecting the original
                       fields onto the spatial pattern of the last 10 years.
                       - if fixed_pattern = False, the pc is calculated by projecting the seasonal
                       data onto to the spatail pattern of this year, in this case, the sptial
                       pattern is gotten by the data ten years around this year. And the length
                       of the index should be shorter than the original series, since not enough
                       years in the begining and the end.
        *return_full_eof*: whether to return the full rolling eofs. if False, only the first and the
                           last eof is returned. if True, it would take a long time.
        *standard* whether the pc (from project field) should be standard with its own std and mean
    **Returns**:

        EOF: The eofs, but now with the first dim as the time.[time-10,mode,lat,lon,(height)]
        PC: the pcs, if fixed_pattern=True, the pcs should be [ens,time,mode]
                     if fixed_pattern=False, the pcs should be [ens,time-10, mode]
        FRA: the explained variances, the shape should be [time-10,mode]
    """

    # the validtime period where totally ten years of data are fully avaiable.
    gap = int(win_size / 2)
    validtime = xarr.isel(time=slice(gap, -1 * gap)).time # valid middle time

    # if do the all-all decompose
    if fixed_pattern == "all":  # a little different from the following two.
        print("     using the all pattern")
        eof_result = ssp.doeof(
            tools.stack_ens(xarr, withdim="time"),
            nmode=nmode,
            dim="com",
            standard=False,
        )

    elif fixed_pattern == "decade":
        print("     decomposing everty ten years")

        # seperate the arr into subarrays, each with win_size length.
        decade_time = validtime[::win_size]

        # make the decade_time as a xarray indexvariable
        decade = xr.IndexVariable("decade", decade_time.values - pd.Timedelta(value=gap *  365.25, unit='D'),attrs= {'note':'sign of decade'}) # the starting year of the decade

        # a list for storing the subarrays
        eofs  = []
        pcs = []
        fras = []

        for time in decade_time:
            print("     decomposing the decade of {}".format(time.dt.year)
            # slice the time
            time_slice = win_slice(time, win_size)

            field = xarr.sel(time=time_slice)
            field = field.stack(com=("ens", "time"))

            eof_result = ssp.doeof(field, nmode=nmode, dim="com")
            eof = eof_result["eof"]
            pc =  eof_result["pc"].copy()
            fra = eof_result["fra"]

            eofs.append(eof)
            pcs.append(pc)
            fras.append(fra)

        # concat the subarrays together, and make the decade as a new dim
        EOF = xr.concat(eofs, dim=decade)
        FRA = xr.concat(fras, dim=decade)
        PC = xr.concat(pcs, 'time')

        # combine EOF, FRA, PC together as a dataset
        eof_result = xr.Dataset({"eof": EOF, "pc": PC, "fra": FRA})

    return eof_result

def win_slice(start_year, win_size):
    """
    get the slice of the window.
    """
    gap = int(win_size / 2)
    y, m, d = str(start_year.values).split("-")
    start_year = np.datetime64("{}-{}-{}".format(int(y)-gap, m, d))
    end_year =  np.datetime64("{}-{}-{}".format(int(y)+gap - 1, m, d))
    return slice(start_year, end_year)
